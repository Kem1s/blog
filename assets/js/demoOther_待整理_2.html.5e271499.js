"use strict";(self.webpackChunkxiaomingblog=self.webpackChunkxiaomingblog||[]).push([[3730],{628:(e,t)=>{t.A=(e,t)=>{const o=e.__vccOpts||e;for(const[e,r]of t)o[e]=r;return o}},8277:(e,t,o)=>{o.r(t),o.d(t,{comp:()=>n,data:()=>i});var r=o(8178);const d={},n=(0,o(628).A)(d,[["render",function(e,t){return(0,r.uX)(),(0,r.CE)("div",null,t[0]||(t[0]=[(0,r.Fv)('<h1 id="vue3-面试题" tabindex="-1"><a class="header-anchor" href="#vue3-面试题"><span>vue3 面试题</span></a></h1><h3 id="_1、vue3-的-composition-api-和-vue2-的-options-api-有什么区别" tabindex="-1"><a class="header-anchor" href="#_1、vue3-的-composition-api-和-vue2-的-options-api-有什么区别"><span>1、Vue3 的 Composition Api 和 Vue2 的 Options Api 有什么区别？</span></a></h3><table><thead><tr><th>类型</th><th>Vue2</th><th>Vue3</th></tr></thead><tbody><tr><td></td><td><strong>Composition Api（组合式）</strong></td><td><strong>Options Api（选项式）</strong></td></tr><tr><td><strong>逻辑组织</strong></td><td>自由度更高，数据和方法可以整合到一起，不用在<code>data</code>、<code>methods</code>之间来回切换</td><td>自由度更差，逻辑太分散，大型组件修改起来困难</td></tr><tr><td><strong>TS 支持度</strong></td><td>完全支持</td><td>支持有限</td></tr><tr><td><strong>响应式数据</strong></td><td>通过<code>Object.defineProperty</code>，无法检测对象属性增减或数组索引变化</td><td>通过<code>Proxy</code> 代理，支持更全面的响应式操作</td></tr><tr><td><strong>逻辑复用</strong></td><td>需要用 minxs,存在命名冲突、来源不透明等问题</td><td>通过自定义组合函数封装，不存在命名冲突</td></tr></tbody></table><hr><h3 id="_2、vue3-的设计目标是什么-做了哪些优化" tabindex="-1"><a class="header-anchor" href="#_2、vue3-的设计目标是什么-做了哪些优化"><span>2、Vue3 的设计目标是什么，做了哪些优化？</span></a></h3><ol><li><strong>设计目标</strong>：主要为了解决以下问题</li></ol><ul><li>随着功能增长，逻辑复杂的组件代码难以维护</li><li>缺少可靠的复用逻辑机制</li><li>类型推断不够友好</li></ul><ol start="2"><li><strong>优化</strong></li></ol><ul><li>去掉不常用 api，体积更小</li><li>优化 diff 算法和响应式实现原理，响应更快</li><li>TypeScript 支持度更高</li><li>可维护性和自由度更高</li></ul><hr><h3 id="_3、vue3-性能提升主要是从哪几个方面体现" tabindex="-1"><a class="header-anchor" href="#_3、vue3-性能提升主要是从哪几个方面体现"><span>3、Vue3 性能提升主要是从哪几个方面体现</span></a></h3><ol><li><strong>diff 算法优化</strong>：新增静态节点标记，数据变化时，只对比动态节点。</li><li><strong>静态提升</strong>：静态节点只会被创建一次，数据变化时，免去了重新创建操作</li><li><strong>事件监听缓存</strong>：同上，数据变化时，免去重新绑定事件操作</li><li><strong>源码体积减小</strong>：去掉了不常用的 api，且所有函数都支持 Tree shanking，没用到的模块不会被打包</li><li><strong>响应式优化</strong>：用<code>proxy</code>重写响应式系统，对数据监听不需要深度遍历，可以监听动态添加的属性，可以监听数组索引和 length，可以监听删除属性等</li></ol><hr><h3 id="_4、为什么要用-proxy-代替-defineproperty" tabindex="-1"><a class="header-anchor" href="#_4、为什么要用-proxy-代替-defineproperty"><span>4、为什么要用 Proxy 代替 defineProperty ？</span></a></h3><ul><li><strong>defineProperty</strong>：是 Object 的方法，一次只能劫持一个属性，多个属性劫持需要遍历。如果是嵌套对象，则需要递归遍历。性能开销较大，而且对对象新增属性、数组通过索引修改数据、数组修改 length 无法监听到。虽然 vue2 对数组的<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code> 7 个方法进行重写，但是其他数组 api 修改数组，依然无法监听到。</li><li><strong>Proxy</strong>：<code>Proxy</code>是对整个对象进行代理，而且是惰性的，只有当访问对象属性时才会触发，性能会更好。而且支持 13 种拦截方式，无需向 vue2 一样重写数组方法。</li></ul><hr><h3 id="_5、说说-vue3-的-tree-shaking-特性" tabindex="-1"><a class="header-anchor" href="#_5、说说-vue3-的-tree-shaking-特性"><span>5、说说 Vue3 的 Tree Shaking 特性</span></a></h3><ul><li><code>Tree Shaking</code>是一种通过清除多余代码，实现减少打包体积的技术。</li><li>vue3 中所有的 api 都是模块化的，用什么 api 就引入什么 api，没有用到的都不会打包。</li></ul><hr><h3 id="_6、说一下-vue3-新特性" tabindex="-1"><a class="header-anchor" href="#_6、说一下-vue3-新特性"><span>6、说一下 Vue3 新特性</span></a></h3><ol><li><strong>新增组合 api</strong>： <code>setup</code>、<code>ref</code>、<code>reactive</code>、<code>toRefs</code>、<code>toRef</code>等</li><li><strong>生命周期变化</strong>：</li></ol><ul><li><strong>创建实例</strong> <code>setup</code>取代<code>beforeCreate</code>、<code>created</code>；</li><li><strong>挂载实例</strong> <code>onBeforeMount</code>、<code>onMounted</code></li><li><strong>更新实例</strong> <code>onBeforeUpdate</code>、<code>onUpdate</code></li><li><strong>销毁实例</strong> <code>onBeforeUnmount</code>、<code>Onmounted</code></li></ul><ol start="3"><li><strong>响应式原理变化</strong>：<code>proxy</code>代理配合<code>Reflect</code>反射取代<code>Object.defindProperty</code></li><li><strong>更好的 TS 支持</strong>: 源码是 TS 写的</li><li><strong>新增内置组件</strong>：<code>Fragment</code>(片段)、<code>Teleport</code>(瞬移)、<code>Suspense</code>(不确定)</li><li><strong>新的脚手架</strong>: vite (虽然我还在用 vue-cli5)</li><li><strong>多节点</strong>：一个组件可以设置多个根节点</li><li><strong>算法优化</strong>：重新 diff 算法、支持 tree-shaking，渲染速度更快、打包体积更小</li><li><strong>取出冗余</strong>：去掉了过滤器 filter，以及一些不常用的 api</li></ol><hr><h3 id="_7、说一下-reactive-和-ref-的区别" tabindex="-1"><a class="header-anchor" href="#_7、说一下-reactive-和-ref-的区别"><span>7、说一下 reactive 和 ref 的区别？</span></a></h3><p><strong>1. 数据类型支持</strong></p><ul><li><code>ref</code>：支持所有类型数据（基础类型和引用类型）</li><li><code>reactive</code>：仅支持数组和对象<br><strong>2. 访问和修改</strong></li><li><code>ref</code>：需通过<code>.value</code>访问和修改（模板中自动解构，不需要<code>.value</code>）</li><li><code>reactive</code>：无需通过<code>.value</code>访问，直接可以访问和修改，（但是需要注意，直接替换会失去响应式，如果部分替换可以用<code>Object.assign</code>）<br><strong>3. 响应式原理</strong></li><li><code>ref</code>：通过<code>Object.defindproperty</code>实现，通过<code>getter/setter</code>拦截<code>.value</code>操作。基本类型被包装成<code>RefImpl</code>对象实现响应式</li><li><code>reactive</code>：通过<code>Proxy</code>代理整个对象，深度拦截属性的读、写、删等操作（支持 13 种拦截类型），嵌套对象自动递归代理。<br><strong>3. 深度响应式行为</strong></li><li><code>ref</code>：若是对象类型，则自动调用<code>reactive</code>转为深度响应式</li><li><code>reactive</code>：默认深度追踪所有嵌套属性</li></ul>',27)]))}]]),i=JSON.parse('{"path":"/demoOther/%E5%BE%85%E6%95%B4%E7%90%86/2.html","title":"vue3 面试题","lang":"zh-CN","frontmatter":{"order":2,"category":["vue3面试题"],"description":"vue3 面试题 1、Vue3 的 Composition Api 和 Vue2 的 Options Api 有什么区别？ 2、Vue3 的设计目标是什么，做了哪些优化？ 设计目标：主要为了解决以下问题 随着功能增长，逻辑复杂的组件代码难以维护 缺少可靠的复用逻辑机制 类型推断不够友好 优化 去掉不常用 api，体积更小 优化 diff 算法和响应式实...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"vue3 面试题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-17T06:58:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Ming\\",\\"url\\":\\"https://kem1s.github.io/blog/\\"}]}"],["meta",{"property":"og:url","content":"https://kem1s.github.io/blog/blog/demoOther/%E5%BE%85%E6%95%B4%E7%90%86/2.html"}],["meta",{"property":"og:site_name","content":"小铭同学"}],["meta",{"property":"og:title","content":"vue3 面试题"}],["meta",{"property":"og:description","content":"vue3 面试题 1、Vue3 的 Composition Api 和 Vue2 的 Options Api 有什么区别？ 2、Vue3 的设计目标是什么，做了哪些优化？ 设计目标：主要为了解决以下问题 随着功能增长，逻辑复杂的组件代码难以维护 缺少可靠的复用逻辑机制 类型推断不够友好 优化 去掉不常用 api，体积更小 优化 diff 算法和响应式实..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-17T06:58:45.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-17T06:58:45.000Z"}]]},"git":{"createdTime":1752587769000,"updatedTime":1752735525000,"contributors":[{"name":"铭723","username":"","email":"8837833+ming-723@user.noreply.gitee.com","commits":2}]},"readingTime":{"minutes":3.87,"words":1161},"filePathRelative":"demoOther/待整理/2.md","excerpt":"\\n<h3>1、Vue3 的 Composition Api 和 Vue2 的 Options Api 有什么区别？</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>类型</th>\\n<th>Vue2</th>\\n<th>Vue3</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td></td>\\n<td><strong>Composition Api（组合式）</strong></td>\\n<td><strong>Options Api（选项式）</strong></td>\\n</tr>\\n<tr>\\n<td><strong>逻辑组织</strong></td>\\n<td>自由度更高，数据和方法可以整合到一起，不用在<code>data</code>、<code>methods</code>之间来回切换</td>\\n<td>自由度更差，逻辑太分散，大型组件修改起来困难</td>\\n</tr>\\n<tr>\\n<td><strong>TS 支持度</strong></td>\\n<td>完全支持</td>\\n<td>支持有限</td>\\n</tr>\\n<tr>\\n<td><strong>响应式数据</strong></td>\\n<td>通过<code>Object.defineProperty</code>，无法检测对象属性增减或数组索引变化</td>\\n<td>通过<code>Proxy</code> 代理，支持更全面的响应式操作</td>\\n</tr>\\n<tr>\\n<td><strong>逻辑复用</strong></td>\\n<td>需要用 minxs,存在命名冲突、来源不透明等问题</td>\\n<td>通过自定义组合函数封装，不存在命名冲突</td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true}')}}]);