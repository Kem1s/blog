---
# icon: pen-to-square
date: 2024-7-23
category:
    - vue3面试题
---

# vue3 面试题

### 1、Vue3 的 Composition Api 和 Vue2 的 Options Api 有什么区别？

| 类型           | Vue2                                                                      | Vue3                                         |
| -------------- | ------------------------------------------------------------------------- | -------------------------------------------- |
|                | **Composition Api（组合式）**                                             | **Options Api（选项式）**                    |
| **逻辑组织**   | 自由度更高，数据和方法可以整合到一起，不用在`data`、`methods`之间来回切换 | 自由度更差，逻辑太分散，大型组件修改起来困难 |
| **TS 支持度**  | 完全支持                                                                  | 支持有限                                     |
| **响应式数据** | 通过`Object.defineProperty`，无法检测对象属性增减或数组索引变化           | 通过`Proxy` 代理，支持更全面的响应式操作     |
| **逻辑复用**   | 需要用 minxs,存在命名冲突、来源不透明等问题                               | 通过自定义组合函数封装，不存在命名冲突       |

---

### 2、Vue3 的设计目标是什么，做了哪些优化？

1. **设计目标**：主要为了解决以下问题

-   随着功能增长，逻辑复杂的组件代码难以维护
-   缺少可靠的复用逻辑机制
-   类型推断不够友好

2. **优化**

-   去掉不常用 api，体积更小
-   优化 diff 算法和响应式实现原理，响应更快
-   TypeScript 支持度更高
-   可维护性和自由度更高

---

### 3、Vue3 性能提升主要是从哪几个方面体现

1. **diff 算法优化**：新增静态节点标记，数据变化时，只对比动态节点。
2. **静态提升**：静态节点只会被创建一次，数据变化时，免去了重新创建操作
3. **事件监听缓存**：同上，数据变化时，免去重新绑定事件操作
4. **源码体积减小**：去掉了不常用的 api，且所有函数都支持 Tree shanking，没用到的模块不会被打包
5. **响应式优化**：用`proxy`重写响应式系统，对数据监听不需要深度遍历，可以监听动态添加的属性，可以监听数组索引和 length，可以监听删除属性等

---

### 4、为什么要用 Proxy 代替 defineProperty ？

-   **defineProperty**：是 Object 的方法，一次只能劫持一个属性，多个属性劫持需要遍历。如果是嵌套对象，则需要递归遍历。性能开销较大，而且对对象新增属性、数组通过索引修改数据、数组修改 length 无法监听到。虽然 vue2 对数组的`push`、`pop`、`shift`、`unshift`、`splice`、`sort`、`reverse` 7 个方法进行重写，但是其他数组 api 修改数组，依然无法监听到。
-   **Proxy**：`Proxy`是对整个对象进行代理，而且是惰性的，只有当访问对象属性时才会触发，性能会更好。而且支持 13 种拦截方式，无需向 vue2 一样重写数组方法。

---

### 5、说说 Vue3 的 Tree Shaking 特性

-   `Tree Shaking`是一种通过清除多余代码，实现减少打包体积的技术。
-   vue3 中所有的 api 都是模块化的，用什么 api 就引入什么 api，没有用到的都不会打包。

---

### 6、说一下 Vue3 新特性

1. **新增组合 api**： `setup`、`ref`、`reactive`、`toRefs`、`toRef`等
2. **生命周期变化**：

-   **创建实例** `setup`取代`beforeCreate`、`created`；
-   **挂载实例** `onBeforeMount`、`onMounted`
-   **更新实例** `onBeforeUpdate`、`onUpdate`
-   **销毁实例** `onBeforeUnmount`、`Onmounted`

3. **响应式原理变化**：`proxy`代理配合`Reflect`反射取代`Object.defindProperty`
4. **更好的 TS 支持**: 源码是 TS 写的
5. **新增内置组件**：`Fragment`(片段)、`Teleport`(瞬移)、`Suspense`(不确定)
6. **新的脚手架**: vite (虽然我还在用 vue-cli5)
7. **多节点**：一个组件可以设置多个根节点
8. **算法优化**：重新 diff 算法、支持 tree-shaking，渲染速度更快、打包体积更小
9. **取出冗余**：去掉了过滤器 filter，以及一些不常用的 api

---

### 7、说一下 reactive 和 ref 的区别？

**1. 数据类型支持**

-   `ref`：支持所有类型数据（基础类型和引用类型）
-   `reactive`：仅支持数组和对象
    **2. 访问和修改**
-   `ref`：需通过`.value`访问和修改（模板中自动解构，不需要`.value`）
-   `reactive`：无需通过`.value`访问，直接可以访问和修改，（但是需要注意，直接替换会失去响应式，如果部分替换可以用`Object.assign`）
    **3. 响应式原理**
-   `ref`：通过`Object.defindproperty`实现，通过`getter/setter`拦截`.value`操作。基本类型被包装成`RefImpl`对象实现响应式
-   `reactive`：通过`Proxy`代理整个对象，深度拦截属性的读、写、删等操作（支持 13 种拦截类型），嵌套对象自动递归代理。
    **3. 深度响应式行为**
-   `ref`：若是对象类型，则自动调用`reactive`转为深度响应式
-   `reactive`：默认深度追踪所有嵌套属性
